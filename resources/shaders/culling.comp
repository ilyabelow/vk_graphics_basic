#version 430
#extension GL_GOOGLE_include_directive : require

#include "common.h"

layout( local_size_x = 32 ) in;

layout( push_constant ) uniform PushConstant {
  Plane leftPlane;
  Plane rightPlane;
  Plane topPlane;
  Plane bottomPlane;
  uint totalInstances;
} params;

layout(std430, binding = 0)  buffer VisibleIdxBuffer
{
    uint visibleIdx[];
};

layout(std430, binding = 1) buffer readonly InstanceDataBuffer
{
    InstanceData instData[];
};

layout(std430, binding = 2) buffer readonly ModelDataBuffer
{
    ModelData modelData[];
};

layout(std430, binding = 3) buffer IndirectCmdBuffer
{
    IndirectCmd indirectCmd[];
};

// naive culling for testing
bool isVisible(uint idx) {
    uint model_i = instData[idx].model;
    vec3 bbmin = (instData[idx].transform * modelData[model_i].bbox.min).xyz;
    vec3 bbmax = (instData[idx].transform * modelData[model_i].bbox.max).xyz;
    vec3 center = (bbmin + bbmax) * .5;
    float r = distance(center, bbmax);
    return (dot(params.leftPlane.n.xyz,   center - params.leftPlane.p.xyz) < r)  &&
           (dot(params.rightPlane.n.xyz,  center - params.rightPlane.p.xyz) < r) &&
           (dot(params.topPlane.n.xyz,    center - params.topPlane.p.xyz) < r)   && 
           (dot(params.bottomPlane.n.xyz, center - params.bottomPlane.p.xyz) < r);
}

void main()  
{
    uint idx = gl_GlobalInvocationID.x;
    // TODO proper voting?
    if (idx < modelData.length()) {
        indirectCmd[idx].instanceCount = 0;
    }
    barrier();
    if (idx < params.totalInstances && isVisible(idx)) {
        uint model_i = instData[idx].model;
        uint curr_visible = atomicAdd(indirectCmd[model_i].instanceCount, 1) + indirectCmd[model_i].firstInstance;
        visibleIdx[curr_visible] = idx;
    }
}